# Job 1 报告

## 1. 重要编译错误

在写这个程序的时候，gcc并没有报错，但是曾经有一个错误差点使我的程序无法运行。我在首次写 `Swap_Int`函数的时候并没有写对。我的第一版代码是这样的：

```
bool SwapInt(int *x, int *y)
{
	int *t;
	*t = *x;
	*x = *y;
	*y = *t;
	return true;
}
```

这样的代码有一个严重的问题：即一开始并没有对 `t`赋值，所以这个存储在计算机中的64位的数值可能（而且极大概率）是任意一个数值。因此，不能够保证 `*t`指向的地方是否是一个已经存在数值的地方。如果 `t`指向 `%rsp`、`%rbp`或者其他已经写入数值的地方，就可能会导致返回地址被覆盖等异常情况。

因此，正确的写法是直接使用int型变量 `t`储存 `*x`的值，或者在声明 `int *t`时为它分配空间，例如

```
int *t = (int *)malloc(sizeof(int));
```

但这种方法比较复杂，还浪费了空间，不是一种明智的选择。

## 2. 调试程序的方法

我使用Visual Studio Code编写了这个程序，原本我应当使用其内置的插件调用GDB并打断点进行调试，但考虑到本次程序十分简单，我一遍就通过了编译和测试了正确性，因此我就没有调试这个程序。

## 3. 测试数据的讨论

我对本程序进行了2组测试，测试数据和原因如下：

1、我的第一组测试数据是 `1 3 9 9 8`，这是一组没有什么规律的数字，旨在测试本程序能否正确处理多个相同数字的排序。经测试，本程序可以处理相同数据的排序。

2、我的第二组测试数据是 `5 4 3 2 1`，这是对于升序的交换排序算法最坏的情况。因此，这样测试可以使代码中的每一行都进行执行而不会跳过任何一个语句。经测试，本程序可以正常工作。

我认为我的测试是科学且合理的。理论上来讲，对于不重复的数据，我应该测试

$$
A_5^5 = 120
$$

种，但我只测试了其中最具有代表性的一组——即最坏情况。因此，这一种情况可以代表其对于不重复数据的表现。对于含有重复数据的输入，我应该测试

$$
C_5^2\cdot A_3^3+C_5^3\cdot A_2^2+C_5^4\cdot1+1=86
$$

种，我挑选了其中最简单的情况——即只有2个数字重复的情况。我认为这种情况可以反应其对于含有重复的输入的表现。

综上所述，我认为我编写了一个正确的程序，且用科学的方法证明了这个程序的正确性。
